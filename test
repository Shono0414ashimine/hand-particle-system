<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Hand-Controlled Particle System</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        #canvas-container {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            z-index: 1;
        }
        /* Hide the raw webcam feed, we only want the data */
        #video-input { display: none; }

        /* UI Panel Styling */
        #ui-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 10;
            background: rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            padding: 20px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.18);
            color: #fff;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            width: 220px;
        }
        .control-group { margin-bottom: 15px; }
        label { display: block; margin-bottom: 5px; font-weight: 500; font-size: 14px;}
        select, input[type=color] {
            width: 100%;
            padding: 8px;
            border-radius: 6px;
            border: none;
            outline: none;
            font-family: inherit;
            cursor: pointer;
        }
        select { background: rgba(0,0,0,0.5); color: #fff; }
        input[type=color] { height: 40px; padding: 2px; background: transparent;}
        
        #loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: white; font-size: 24px; z-index: 20; pointer-events: none;
        }
    </style>
</head>
<body>
    <div id="loading">Loading AI Models...</div>

    <div id="ui-panel">
        <div class="control-group">
            <label for="template-select">Template Style</label>
            <select id="template-select">
                <option value="0">Saturn Rings</option>
                <option value="1">Floating Hearts</option>
                <option value="2">Flowers</option>
                <option value="3">Fireworks</option>
            </select>
        </div>
        <div class="control-group">
            <label for="color-picker">Base Color</label>
            <input type="color" id="color-picker" value="#00ffff">
        </div>
        <p style="font-size: 12px; opacity: 0.7; margin-top: 20px;">
            Current Interaction:<br>
            - <b>Pinch</b> fingers to scale down.<br>
            - <b>Spread</b> hands apart to expand area.
        </p>
    </div>

    <video id="video-input"></video>
    <div id="canvas-container"></div>

<script>
    // --- Configuration ---
    const PARTICLE_COUNT = 8000;
    let isSystemReady = false;

    // --- Global State ---
    let scene, camera, renderer, particleSystem, uniforms;
    let handGestureData = {
        pinch: 0.0, // 0.0 (pinched) to 1.0 (open)
        spread: 0.5 // 0.0 (hands together) to 1.0 (hands far apart)
    };

    // Texture Data URIs for shapes (simple white shapes on transparent bg)
    const heartTex = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAAABmJLR0QA/wD/AP+gvaeTAAAB9klEQVRoge2ZzU4CMRCFz8UIEoxGjUYT9Qn0ybu+gQ/iE7jSxcSNvv0TuDAaF0Yk3ExZaRvAP2inddKbtNMzbT76ZtqBwrIsy7Is61/I5FMAk6rW83oAmAHIBg69BjAIHNQEsFvVal4P0wDCAE77Dt0GMA2c4xQ4j+f08/mP/l63u06r1bZut0O93iCVSuHhYcy2bUwmE0ynU8xmM0SjUSQSCRiGAbB/36mEaYCvqh95PVQA1Ot1tNtt+L4PAGi32+j1ekgmk/A8Ly6Ay/sONQJQKBSQz+fhuq6pXdc1gZTLZeTzeSgAF+ccugsgCqBarZqg9lWlUgGgB3Df10E9AMXjceRyOdi2vVfbtmHbNnK5HOLxuAnA2d1BbQCZTAaFQiG0oEKhgEwmYwL47OyglgAymQxyuVxoQbZtI5PJmABc9h768L5TA0AqlaIkqFqtkqIoTdOE7/um9/F4HD/A399G7QCGw6HpxH6/b2rf7/dNZw6HQ9P7ZDKJH2A+n8d3YDAYxHaQtN9+v28C8DwPZ+H8g6YdIEmS8Xgc20GdTgdJkowfgD5A3w4QjUYxGo1iO2g0GiEajZoA/lX106q1/j0wDAOpVIr+C8gJ8A6g4fVQAeCa8N/Xf/z9P086APqB86h/C74A+Abw6vW4sCzLsiyr7P4AAX1p1YdSHvUAAAAASUVORK5CYII=';
    const flowerTex = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAAABmJLR0QA/wD/AP+gvaeTAAACeElEQVRoge2XzU4aQRTHf7tLFwttE2svNqYn06Snb4BP4GP0CXwT6bX20kR7M03qg2hM1CZq1EBI78OAs4sZdyi4bJmZ/Z8m2eFhfsMvM/85gwlMZCJz4p9+A9XW/m8uFv16f+94Y1wA+AB4wI/O+B342hhXf78YV1v7v3kX5+c8Pj4C0O12ubq6Yn9/n8vLy9741dVV3261WtTrdTzPw7IspJR4nsdgMODr169IKeecO3XGJUBKSaPR6I23Wi3a7TbT6RTbtlFKMZ1OyWazeJ5HpVLBOcc349ILoK16vf4NfK1WI0kSIBD4+fk5lUrla/gQ+KkXgG1Z1qD3g3q9jguBvwH46R3BjuM4Q23HcVAKfAd+6gWQTCaTIbZJkjAZ+E/gP3oBrJ6fn4fYPjw89IF/Aj/1AgB4eHgYYjuZTHqDvwF/9QIAKJfLQ2zL5XIv8DfwSy8A3/dP0jQdYpulKf7gX8BvvQBKqW+DwWCINUlTjMHPBf7oBQBQKBR+9Ho9kiQZ2pYkCZ1OB6UUKPhTgd96AdTr9T1gdTAYDLVdDYY4jrMA/FTgr14A+/v7u8Bqv98f+q6SNGX4/f8C/Fw5gE2v18M5hzHmk+0Yg3MOr9fr9f4H+LlyAJtSqYSUcqgN0N+NlFJIKXv9vwB/9AJwHOe4XC4j5fCno5RCyqH7gH/jZ/wWIFhaWlrXWs8c1loD4Pu+X1haWlo/Oz09c77Z9L/uF+c8PT0N/L/fF5cAj4+Pv7XW/Z0/Pz8D7Y2fmp44F4C/wA/gm9b6d+t777UxtrUxtv+4W1v7v7mNcfXvB/C1Ma7++8W42tpz6R97z8i0vQ8nCAAAAABJRU5ErkJggg==';


    // --- 1. Three.js Setup ---
    function initThree() {
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        // Position camera further back to see the whole system clearly
        camera.position.z = 50; 

        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        createParticleSystem();
        setupUI();

        window.addEventListener('resize', onWindowResize, false);
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }


    // --- 2. Particle System with Custom Shaders ---
    function createParticleSystem() {
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(PARTICLE_COUNT * 3);
        const randoms = new Float32Array(PARTICLE_COUNT * 3); // For varied movement

        for (let i = 0; i < PARTICLE_COUNT; i++) {
            // Initial sphere distribution
            const r = 10 + Math.random() * 20;
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos(2 * Math.random() - 1);

            positions[i * 3] = r * Math.sin(phi) * Math.cos(theta);
            positions[i * 3 + 1] = r * Math.sin(phi) * Math.sin(theta);
            positions[i * 3 + 2] = r * Math.cos(phi);

            randoms[i * 3] = Math.random(); // random offset x
            randoms[i * 3 + 1] = Math.random(); // random offset y
            randoms[i * 3 + 2] = Math.random(); // random speed factor
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('aRandom', new THREE.BufferAttribute(randoms, 3));

        // Load textures
        const loader = new THREE.TextureLoader();
        const heartTexture = loader.load(heartTex);
        const flowerTexture = loader.load(flowerTex);

        // --- Shaders ---
        
        // Vertex Shader: Handles positioning based on time and hand input
        const vertexShader = `
            uniform float uTime;
            uniform float uPinch; // 0.0 (pinched) to 1.0 (open)
            uniform float uSpread; // 0.0 (close) to 1.0 (far)
            uniform int uTemplateCmd; // 0: Saturn, 1: Hearts, 2: Flowers, 3: Fireworks

            attribute vec3 aRandom;

            varying vec3 vPos;
            varying vec3 vRandom;

            void main() {
                vRandom = aRandom;
                vec3 pos = position;
                float scale = 1.0;

                // Base interaction: Scaling based on pinch
                // Map pinch (0-1) to scale (e.g., 0.2 to 2.0)
                float pinchScale = mix(0.2, 2.5, uPinch); 

                // Base interaction: Expansion based on spread
                float expansionFactor = mix(0.5, 4.0, uSpread);


                if (uTemplateCmd == 0) { 
                    // --- Saturn Rings ---
                    // Flatten Y, expand XZ based on spread
                    float angle = atan(pos.z, pos.x) + uTime * (0.1 + aRandom.z * 0.2);
                    float radius = length(vec2(pos.x, pos.z)) * expansionFactor;
                    // Add some vertical noise
                    pos.y = pos.y * 0.1 * expansionFactor + sin(angle * 5.0 + uTime) * 2.0;
                    pos.x = cos(angle) * radius;
                    pos.z = sin(angle) * radius;
                    scale = pinchScale * (0.5 + aRandom.x);

                } else if (uTemplateCmd == 3) {
                    // --- Fireworks ---
                    // Explode outwards from center repeatedly
                    float explosionTime = mod(uTime * (0.5 + aRandom.z), 3.0);
                    vec3 direction = normalize(pos);
                    // Velocity depends on spread
                    float velocity = (10.0 + aRandom.y * 20.0) * expansionFactor;
                    pos = direction * velocity * explosionTime;
                    // Gravity effect
                    pos.y -= explosionTime * explosionTime * 2.0; 
                    // Fade out scale at end of life
                    scale = pinchScale * (1.0 - explosionTime / 3.0);

                } else {
                    // --- Hearts & Flowers (Floating Cloud) ---
                    // Gentle floating + expansion
                    pos.x += sin(uTime * aRandom.z + aRandom.x * 10.0) * 5.0;
                    pos.y += cos(uTime * aRandom.y + aRandom.z * 10.0) * 5.0;
                    pos.z += sin(uTime * aRandom.x + aRandom.y * 10.0) * 5.0;
                    
                    pos *= expansionFactor;
                    scale = pinchScale * (1.0 + aRandom.x);
                }

                vPos = pos;
                vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                
                // Size attenuation (particles get smaller further away)
                gl_PointSize = (20.0 * scale) * (300.0 / -mvPosition.z);
                gl_Position = projectionMatrix * mvPosition;
            }
        `;

        // Fragment Shader: Handles shape and color
        const fragmentShader = `
            uniform vec3 uColor;
            uniform int uTemplateCmd;
            uniform sampler2D uHeartTex;
            uniform sampler2D uFlowerTex;

            varying vec3 vPos;
            varying vec3 vRandom;

            void main() {
                vec4 texColor;

                if (uTemplateCmd == 1) {
                    // Hearts
                    texColor = texture2D(uHeartTex, gl_PointCoord);
                } else if (uTemplateCmd == 2) {
                    // Flowers
                    texColor = texture2D(uFlowerTex, gl_PointCoord);
                } else {
                    // Saturn / Fireworks (Simple circles)
                    // Calculate distance from center of point sprite
                    float dist = length(gl_PointCoord - vec2(0.5));
                    if (dist > 0.5) discard; // Make it round
                    // Soft edge
                    float alpha = 1.0 - smoothstep(0.3, 0.5, dist);
                    texColor = vec4(1.0, 1.0, 1.0, alpha);
                }

                // Apply base color, add slight variation based on position and random seed
                vec3 finalColor = uColor + vPos * 0.005 + vRandom * 0.1;

                gl_FragColor = vec4(finalColor, 1.0) * texColor;
                 if (gl_FragColor.a < 0.1) discard;
            }
        `;

        uniforms = {
            uTime: { value: 0 },
            uPinch: { value: 1.0 },
            uSpread: { value: 0.5 },
            uColor: { value: new THREE.Color(0x00ffff) },
            uTemplateCmd: { value: 0 }, // Start with Saturn
            uHeartTex: { value: heartTexture },
            uFlowerTex: { value: flowerTexture }
        };

        const material = new THREE.ShaderMaterial({
            uniforms: uniforms,
            vertexShader: vertexShader,
            fragmentShader: fragmentShader,
            transparent: true,
            depthWrite: false, // Important for dense particle clouds
            blending: THREE.AdditiveBlending // Glowing effect
        });

        particleSystem = new THREE.Points(geometry, material);
        scene.add(particleSystem);
    }


    // --- 3. MediaPipe Hands Setup ---
    function setupMediaPipe() {
        const videoElement = document.getElementById('video-input');
        
        const hands = new Hands({locateFile: (file) => {
            return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
        }});

        hands.setOptions({
            maxNumFaces: 2, // Track both hands
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        hands.onResults(onHandsResults);

        const cameraFeed = new Camera(videoElement, {
            onFrame: async () => {
                await hands.send({image: videoElement});
            },
            width: 640,
            height: 480
        });
        cameraFeed.start();
    }

    function onHandsResults(results) {
        if (!isSystemReady) {
            document.getElementById('loading').style.display = 'none';
            isSystemReady = true;
        }

        let totalPinch = 0;
        let totalSpread = 0;
        let handCount = 0;

        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            results.multiHandLandmarks.forEach(landmarks => {
                handCount++;
                
                // --- Calculate Pinch (Thumb Tip to Index Tip distance) ---
                // Landmark 4 (Thumb tip), Landmark 8 (Index tip)
                const thumbTip = landmarks[4];
                const indexTip = landmarks[8];
                // Simple 2D distance calculation is usually enough
                const pinchDist = Math.sqrt(
                    Math.pow(thumbTip.x - indexTip.x, 2) + 
                    Math.pow(thumbTip.y - indexTip.y, 2)
                );
                // Normalize: pinchDist is roughly 0.02 (closed) to 0.2 (open)
                // We want 0.0 (closed) to 1.0 (open)
                let normalizedPinch = (pinchDist - 0.02) / (0.15 - 0.02);
                totalPinch += Math.max(0, Math.min(1, normalizedPinch)); // Clamp 0-1

                // --- Calculate Hand Spread/Tension ---
                // Distance from Wrist (0) to Middle Finger Tip (12) gives a rough size approximation
                // Then compare neighbor fingers for spread, but wrist-to-tip is simpler for "area"
                const wrist = landmarks[0];
                const middleTip = landmarks[12];
                const spreadDist = Math.sqrt(
                     Math.pow(wrist.x - middleTip.x, 2) + 
                     Math.pow(wrist.y - middleTip.y, 2)
                );
                // Normalize: spreadDist roughly 0.2 (relaxed) to 0.4 (stretched tight)
                let normalizedSpread = (spreadDist - 0.2) / (0.4 - 0.2);
                 totalSpread += Math.max(0, Math.min(1, normalizedSpread));

            });
        }

        // Average the results if two hands are present
        if (handCount > 0) {
            handGestureData.pinch = totalPinch / handCount;
            handGestureData.spread = totalSpread / handCount;
        } else {
            // Default values if no hands detected (slowly drift back)
            handGestureData.pinch = handGestureData.pinch * 0.95 + 1.0 * 0.05; 
            handGestureData.spread = handGestureData.spread * 0.95 + 0.5 * 0.05;
        }
    }

    // --- 4. UI and Main Loop ---
    function setupUI() {
        const templateSelect = document.getElementById('template-select');
        const colorPicker = document.getElementById('color-picker');

        templateSelect.addEventListener('change', (e) => {
            uniforms.uTemplateCmd.value = parseInt(e.target.value);
        });

        colorPicker.addEventListener('input', (e) => {
            uniforms.uColor.value = new THREE.Color(e.target.value);
        });
    }

    function animate() {
        requestAnimationFrame(animate);
        
        if(uniforms) {
            // Update uniforms
            uniforms.uTime.value += 0.02;
            
            // Smoothly interpolate gesture data into uniforms for less jittery reaction
            uniforms.uPinch.value += (handGestureData.pinch - uniforms.uPinch.value) * 0.1;
            uniforms.uSpread.value += (handGestureData.spread - uniforms.uSpread.value) * 0.1;
        }

        // Slowly rotate the whole system for better 3D perception
        if(particleSystem) {
            particleSystem.rotation.y += 0.001;
        }

        renderer.render(scene, camera);
    }

    // --- Initialize ---
    initThree();
    setupMediaPipe();
    animate();

</script>
</body>
</html>
